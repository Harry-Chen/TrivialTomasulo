# Tomasulo 算法模拟器设计与分析 实验报告

计63 陈晟祺 2016010981

## 实验设计

TrivialTomasulo Simulator 是使用 TypeScript 开发的 Tomasulo 乱序执行算法模拟器，分为前端与后端两部分。后端负责指令执行的模拟与数据存储，前端用于显示状态与将请求发送给后端。两部分都被集成在客户端代码中，使用 Redux 进行分发与状态管理，可以完全离线运行。

模拟器中共有6个加减法保留站（ARS1-6）、3个乘除法保留站（MRS1-3）、3个数据缓冲器（LB1-3），同时，提供了3个加减法单元（Add1-3）、2个乘除法单元（Mul1-2）、2个加载单元（Load1-2）。

模拟器运行以时钟周期为单位，起始是为第0周期，显示每一周期结束时的状态。每当前端触发下一周期的计算，后端将进行以下工作（代码祝好位于 `src/redux/tomasuloReducer.ts` 与 `src/redux/action.ts` 中）：

1. 如果还有指令没有执行完毕，则将当前的时钟周期 + 1，否则直接退出
2. 记录当前周期是否需要等待（`stall` 为 `false`）
3. 按照序号检查所有的保留站，如果存在操作数全部就绪的指令，并且对应的功能单元有空闲，则将其送到功能单元开始执行并标记状态（该指令剩余周期=指令开销-1）。这一步中会特别检查 `DIV` 指令操作数，如果被除数为0，则将其修改为1；并且对于**所有**被除数为1的 `DIV` 指令，其执行代价将会被**修改为1**。
4. 按照序号检查所有的保留站，如果存在当周期结束执行的指令，则释放对应的功能单元，并标记指令状态为执行完成。这一步中，跳转系列指令将进行求值，按条件更改 PC 的值并置 `stall` 为 `false`，允许下一周期开始继续发射指令。
5. 按照序号检查所有的保留站，如果存在当周期需要写入的指令，则在 CDB 上广播相应结果信息和来源，并释放保留站。其余所有保留站以及寄存器状态组件都将检查自身是否等待对应保留站的操作数，如果有，则移除对应组件等待状态，并将对应值写入寄存器或者保留站的 `V` 区域。最后，释放这一指令使用的保留站，并标记指令为写入完成。
6. 如果 2 中的标记与 `fetchEnd` 都不为 `true`，则进入指令发射阶段。如果当前 PC 对应的指令所需的保留站有空闲，则将其送入保留站，并设置源操作数的状态（取值或者设置源保留站名称）和目标寄存器状态。这一步如果遇到跳转指令，会将 `stall` 置为 `true`，防止下一周期过早进行指令发射。如果不是跳转指令，则将 PC 自增，如果 PC 超出指令范围，说明接下来不再有指令发射，标记 `fetchEnd` 为 `true`。

## 实现差异

与实验要求中不同的是，我的算法实现有以下的差异：

* 我没有将跳转指令使用整数运算保留站/功能单元进行求值，而是使用了独立的跳转单元处理（没有在前端显示出来）。这是由于两者行为事实上并不一致，包括运算代价和执行后的行为；将它们使用同样的单元处理不仅违反了软件设计上 OO 的原则，也与现实中很多硬件实现并不符合。这一实现会在某些整数运算密集情况下（如多条连续加减指令后跟随跳转指令），加快指令的发射和执行时间，减少（我认为不必要的）等待时间。
* 在发生 WAW 后，前一个命令的结果不实际写入寄存器。我认为这是没有必要的，因为前一条指令的 W 结果如果被中间的指令需要，就已经被相应的保留站所接受了。在硬件实现中，寄存器状态组件并没有必要记录它的“前一个写入者”信息；也就是说，一旦发生了 WAW，则寄存器只会等到后一个W执行完后才会被修改。因为寄存器状态组件中，对应的寄存器值来源已经被修改为后一个指令的保留站，它会忽略CDB上广播的前一条W指令的结果。这样实现并不影响任何指令的执行过程、结果和所有指令执行完后的寄存器的值，是 **“最终一致”** 的。

此外，除了算法，还有下面的细节差异：

* 除了原指令中，其余部分（保留站、寄存器状态等）的地址和立即数都显示为带符号十进制值。这减少了阅读十六进制和补码带来的不方便。

## 实现功能

除了基本功能外，我还实现了以下的额外/增强功能：

* 使用 React 与 Material-UI 框架，设计了一个较为直观、简洁的用户界面，并能够在任意平台上运行（只需要现代浏览器支持）。
* 在控制台以人类可读的格式输出每一个改变状态的行为，如指令的发射、执行、结束等，方便调试。
* 支持单步、多步运行（可指定周期数）、自动运行与停止、直接执行到指令结束。自动判断，当结束时不再继续执行并在 UI 上进行提示。
* 为 NEL 语言增加指令：
  * `JE, JNE, JLE, JL, JGE, JG` 跳转指令：语义与 x86 指令对应，能够更方便地表达多种逻辑。
  * `MOVE` 移动指令：从一个寄存器复制数值到另一个，与 LD 指令共用 Load 保留站和功能单元。这一指令比较特殊，执行阶段不花费时间，一旦就绪则下一周期直接进行写入。

## 实例测试

我撰写了两个测例用于测试实现的正确性，保存在 `tests` 文件夹中，下面予以说明：

### 乘加组合

```text
LD,F1,0x2
LD,F2,0x2
MUL,F3,F1,F2
ADD,F4,F4,F3
ADD,F2,F2,F1
JLE,0x0A,F2,0xFFFFFFFD
```

这一程序计算 $2 \times 2 + 2 \times 4 + 2 \times 6 + 2 \times 8 + 2 \times 10$ 并将其写入寄存器 `F4` 中。由于 `MUL` 指令耗时较长，而下面的自增与跳转指令不依赖它的结果，因此等待期间，可以发射更多的指令。

通过 TrivialTomasulo 的模拟，可以看到，在第 17 周期，MRS1 中为第一次循环时计算的乘法，MRS2 中为第二次循环时计算的乘法，两者完成时间差 6 周期，恰好是两条 ADD 和JLE 指令执行的时间之和。而前三个 ARS 中均有 ADD 指令，分别是两个等待 MUL 的 ADD 和第二个循环中 F2 的自增操作。最终程序在第 53 周期完成了所有的指令，得到了正确的结果 60。

### 斐波那契数列

```text
LD,F1,0x1
LD,F2,0x1
LD,F3,0x1
LD,F4,0x1
ADD,F5,F3,F4
MOVE,F3,F4
MOVE,F4,F5
ADD,F1,F2,F1
JLE,0x0F,F1,0xFFFFFFFC
```

上面的程序计算斐波那契数列的第 17 项，并存储在 `F4` 中。可以看到，第6行的 MOVE 命令总是可以在第五行的 ADD 命令之前执行，而对 `F1` 的自增可以与上面所有命令并行。因此，Tomasulo 带来的乱序执行可以有效提升这段程序的笑效率。最终，程序使用 141 个周期完成了计算，得到结果为 1597，是正确的。

## 编译运行

代码编译方法与使用帮助可参见 `source.zip` 中的 `README.md`。直接打开源码目录中的 `dist/index.html` 文件即可运行。在提交的 `dist` 目录中附有一份最新的编译版本，也可直接访问 [在线版本](https://tomasulo.harrychen.xyz)。

在作业结束后，本项目将在 [GitHub](https://github.com/Harry-Chen/TrivialTomasulo) 以 MIT 协议开放源代码。

## 项目参考

本项目的开发仅参考了实验指导书与课程讲义，没有参考任何现有的实现。
